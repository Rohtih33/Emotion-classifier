# -*- coding: utf-8 -*-
"""emotion

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AH8xfl1tUZZXQku8BH-Tsz1PjKeUTaCq
"""

# Install required libraries
!pip install --upgrade datasets scikit-learn

# Import necessary libraries
from datasets import load_dataset
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.svm import SVC
from sklearn.pipeline import Pipeline
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
import re
import string

# Load the emotion dataset from HuggingFace
dataset = load_dataset("dair-ai/emotion")

# Extract the text and labels for training and testing
train_texts = dataset['train']['text']
train_labels = dataset['train']['label']
test_texts = dataset['test']['text']
test_labels = dataset['test']['label']

# Get the list of emotion categories
label_names = dataset['train'].features['label'].names
print("Emotion categories:", label_names)

# Function to clean the text data
def clean_text(text):
    text = text.lower()
    text = re.sub(r"http\S+|www\S+", '', text)      # remove urls
    text = re.sub(r"@\w+|#", '', text)             # remove mentions and hashtags
    text = text.translate(str.maketrans('', '', string.punctuation))  # remove punctuation
    text = re.sub(r"\d+", '', text)                # remove numbers
    return text.strip()

# Clean the training and test data
train_clean = [clean_text(t) for t in train_texts]
test_clean = [clean_text(t) for t in test_texts]

# Try different SVM kernels and evaluate performance
kernels = ['linear', 'poly', 'rbf', 'sigmoid']
accuracy_scores = {}

for kernel in kernels:
    print(f"\nTraining SVM with {kernel} kernel")

    # Build a pipeline with TF-IDF vectorizer and SVM classifier
    model = Pipeline([
        ('tfidf', TfidfVectorizer(stop_words='english', ngram_range=(1,2), max_features=10000)),
        ('svm', SVC(kernel=kernel, C=1.0, gamma='scale'))
    ])

    # Train the model
    model.fit(train_clean, train_labels)

    # Make predictions on the test data
    predictions = model.predict(test_clean)

    # Evaluate the model
    acc = accuracy_score(test_labels, predictions)
    print(f"Accuracy: {acc:.4f}")
    print("Classification Report:\n", classification_report(test_labels, predictions, target_names=label_names))
    print("Confusion Matrix:\n", confusion_matrix(test_labels, predictions))

    # Store the accuracy for this kernel
    accuracy_scores[kernel] = acc

# Print the best performing kernel and its accuracy
best_kernel = max(accuracy_scores, key=accuracy_scores.get)
print(f"\nBest performing kernel: {best_kernel} with accuracy {accuracy_scores[best_kernel]:.4f}")